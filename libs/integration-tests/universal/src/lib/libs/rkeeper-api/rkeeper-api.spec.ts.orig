import { ECS } from 'aws-sdk';
import * as R from 'ramda';
import * as fs from 'fs';
import * as CrudApi from '@bgap/crud-gql/api';
import { createIamCrudSdk } from '../../../api-clients';
import {
  mergeMap,
  switchMap,
  delay,
  tap,
  switchMapTo,
  takeLast,
  toArray,
  map,
  count,
} from 'rxjs/operators';
import {
  createRkeeperProduct,
  updateRkeeperProduct,
  searchExternalUnitProduct,
  getBusinessEntityInfo,
  handleRkeeperProducts,
  createDefaultProductCategory,
  defaultProductCategoryId,
  handleProducts,
} from '@bgap/rkeeper-api';
import { from, Observable, combineLatest, of } from 'rxjs';
import { ES_DELAY, maskV4UuidIds, dateMatcher } from '../../../utils';
import { filterNullishGraphqlListWithDefault } from '@bgap/shared/utils';
import { pipe } from 'fp-ts/lib/function';
import * as fixtures from './fixtures';
import { deleteGeneratedProductsForAUnitFromDb } from '@bgap/backend/products';
import { getAllPaginatedData } from '@bgap/gql-sdk';
import * as stackConfig from '../../generated/stack-config.json';
import * as commonStackConfig from '../../generated/common-stack-config.json';

describe('Test the rkeeper api basic functionality', () => {
  const crudSdk = createIamCrudSdk();

  const testItemDeleter = <Y extends { id: string }, FILTER>(
    searchOp: (x: { filter: FILTER }) => Observable<
      | {
          items?: CrudApi.Maybe<Array<CrudApi.Maybe<Y>>>;
        }
      | undefined
      | null
    >,
    deleteOp: (x: { input: { id: string } }) => any,
    filter: FILTER,
  ) =>
    getAllPaginatedData(searchOp, {
      query: { filter },
    }).pipe(
      filterNullishGraphqlListWithDefault<Y>([]),
      tap(items => console.log(`Found ${items.length} items do delete`)),
      switchMap(from),
      mergeMap((item: Y) =>
        deleteOp({
          input: { id: item.id },
        }),
      ),
      toArray(),
    );

  const dirtyItemDeleter = <Y extends { id: string }>(
    searchOp: (x: { filter: { dirty: { eq: boolean } } }) => Observable<
      | {
          items?: CrudApi.Maybe<Array<CrudApi.Maybe<Y>>>;
        }
      | undefined
      | null
    >,
    deleteOp: (x: { input: { id: string } }) => any,
  ) => testItemDeleter(searchOp, deleteOp, { dirty: { eq: true } });

  const chainDataDeleter = <Y extends { id: string }>(
    searchOp: (x: { filter: { chainId: { eq: string } } }) => Observable<
      | {
          items?: CrudApi.Maybe<Array<CrudApi.Maybe<Y>>>;
        }
      | undefined
      | null
    >,
    deleteOp: (x: { input: { id: string } }) => any,
    chainId: string,
  ) => testItemDeleter(searchOp, deleteOp, { chainId: { eq: chainId } });

  const cleanup$ = combineLatest(
    dirtyItemDeleter(crudSdk.SearchUnitProducts, crudSdk.DeleteUnitProduct),
    dirtyItemDeleter(crudSdk.SearchGroupProducts, crudSdk.DeleteGroupProduct),
    dirtyItemDeleter(crudSdk.SearchChainProducts, crudSdk.DeleteChainProduct),
    chainDataDeleter(
      crudSdk.SearchProductComponents,
      crudSdk.DeleteProductComponent,
      fixtures.rkeeperUnit.chainId,
    ),
    chainDataDeleter(
      crudSdk.SearchProductComponentSets,
      crudSdk.DeleteProductComponentSet,
      fixtures.rkeeperUnit.chainId,
    ),
  ).pipe(
    switchMap(() =>
      from([fixtures.rkeeperUnitProduct, fixtures.rkeeperUnitProduct2]),
    ),
    mergeMap(
      item =>
        crudSdk.DeleteUnitProduct({
          input: { id: item.id },
        }),
      100,
    ),
    mergeMap(
      item =>
        crudSdk.DeleteProductCategory({
          input: {
            id: defaultProductCategoryId({
              chainId: fixtures.rkeeperUnit.chainId,
            }),
          },
        }),
      100,
    ),
    count(),
    tap(num => console.log(`${num} deleted items`)),
    switchMap(() =>
      combineLatest(
        crudSdk.DeleteUnit({ input: { id: fixtures.rkeeperUnit.id } }),
        crudSdk.DeleteGroup({ input: { id: fixtures.createGroup.id } }),
        crudSdk.DeleteChain({ input: { id: fixtures.createChain.id } }),
        deleteGeneratedProductsForAUnitFromDb(crudSdk)(''),
      ),
    ),
    tap(result => console.log(`${result} deleted items`)),
  );

  beforeEach(done => {
    jest.resetModules();

    of(1)
      .pipe(
        delay(ES_DELAY),
        switchMap(() => cleanup$),
        delay(ES_DELAY),
        switchMapTo(
          from([fixtures.rkeeperUnitProduct, fixtures.rkeeperUnitProduct2]),
        ),
        mergeMap(input => crudSdk.CreateUnitProduct({ input })),
        takeLast(1),
        switchMap(() =>
          combineLatest(
            crudSdk.CreateUnit({ input: fixtures.rkeeperUnit }),
            crudSdk.CreateGroup({ input: fixtures.createGroup }),
            crudSdk.CreateChain({ input: fixtures.createChain }),
          ),
        ),
        delay(ES_DELAY),
      )
      .subscribe(() => done());
  }, 65000);

  afterAll(done => {
    cleanup$.subscribe(() => done());
  }, 30000);

  test('It shouls be able to search for external product', done => {
    searchExternalUnitProduct(crudSdk)(fixtures.rkeeperProductGuid)
      .pipe(
        tap(res =>
          expect(res?.id).toMatchSnapshot('existing external product'),
        ),
        switchMap(() =>
          searchExternalUnitProduct(crudSdk)('NOT EXISTING PRODUCT'),
        ),
        tap(res =>
          expect(res).toMatchSnapshot('NOT existing external product'),
        ),
      )
      .subscribe(() => done());
  });

  test('Create products by an rkeeper product', done => {
    const matcher = (expectParentId = true) =>
      pipe(
        {
          createdAt: expect.any(String),
          updatedAt: expect.any(String),
          id: expect.any(String),
        },
        item =>
          expectParentId ? { ...item, parentId: expect.any(String) } : item,
      );

    const verifyer = <Y>(
      op: (x: { filter: { dirty: { eq: boolean } } }) => Observable<
        | {
            items?: CrudApi.Maybe<Array<CrudApi.Maybe<Y>>>;
          }
        | undefined
        | null
      >,
      label: string,
      expectParentId = true,
    ) =>
      op({ filter: { dirty: { eq: true } } }).pipe(
        filterNullishGraphqlListWithDefault<Y>([]),
        tap(res =>
          expect(res).toMatchSnapshot([matcher(expectParentId)], label),
        ),
      );

    createRkeeperProduct(crudSdk)(
      fixtures.businessEntity,
      fixtures.processedDish,
      [],
    )
      .pipe(
        delay(ES_DELAY),
        switchMap(() =>
          combineLatest(
            verifyer<CrudApi.UnitProduct>(
              crudSdk.SearchUnitProducts,
              'UNITPRODUCTS',
            ),
            verifyer<CrudApi.GroupProduct>(
              crudSdk.SearchGroupProducts,
              'GROUPPRODUCTS',
            ),
            verifyer<CrudApi.ChainProduct>(
              crudSdk.SearchChainProducts,
              'CHAINPRODUCTS',
              false,
            ),
          ),
        ),
        map(([unitProducts]) => unitProducts[0]),
        switchMap(unitProduct =>
          updateRkeeperProduct(crudSdk)(
            { ...fixtures.processedDish, name: 'NEW NAME', price: 1000000 },
            unitProduct,
            [],
          ),
        ),
        tap(res =>
          expect(res).toMatchSnapshot(matcher(), 'update rkeeper product'),
        ),
      )
      .subscribe(() => done());
  }, 15000);

  test('getBusinessEntityInfo - not existing restaurant', done => {
    getBusinessEntityInfo(crudSdk)('NOT EXISTING RESTO`').subscribe({
      error: (err: unknown) => {
        expect(err).toMatchSnapshot();
        done();
      },
    });
  });

  test('getBusinessEntityInfo - existing restaurant', done => {
    getBusinessEntityInfo(crudSdk)(
      fixtures.rkeeperUnit.externalId ?? 'something is wrong',
    ).subscribe({
      next: result => {
        expect(result).toMatchSnapshot();
        done();
      },
    });
  });

  test('Test full rkeeper product handling - not not existing unit', done => {
    handleRkeeperProducts(crudSdk)(
      'NOT EXISTING RESTAURANT',
      fixtures.rawData,
    ).subscribe({
      error: err => {
        expect(err).toMatchSnapshot();
        done();
      },
    });
  }, 15000);

  test('Test full rkeeper product handling - the use case', done => {
    const createMatcher =
      (matcher: Record<string, unknown>) =>
      (label: string) =>
      (result: any[]) =>
        pipe(
          result,
          maskV4UuidIds,
          R.sortBy(JSON.stringify),
          R.forEach(res => expect(res).toMatchSnapshot(matcher, label)),
        );

    const checkMatches = createMatcher(dateMatcher);

    const sortConfigSets = <
      T extends {
        items?: CrudApi.Maybe<
          CrudApi.GeneratedProductConfigSet | CrudApi.ProductConfigSet
        >;
      },
    >(
      sets: CrudApi.Maybe<T>[],
    ) =>
      pipe(
        sets,
        R.map(configSet => ({
          ...configSet,
          items: !!configSet?.items
            ? pipe(
                (configSet?.items ?? []) as CrudApi.Maybe<
                  CrudApi.ProductConfigSet | CrudApi.GeneratedProductConfigSet
                >[],
                R.reject(R.isNil),
                R.sortBy(JSON.stringify),
              )
            : R.identity,
        })),
        R.sortBy(JSON.stringify),
      );

    const processProducts = <
      K,
      T extends {
        configSets?: CrudApi.Maybe<CrudApi.Maybe<K>[]>;
      },
    >(
      products: T[],
    ) =>
      pipe(
        products,
        maskV4UuidIds,
        R.map(product => ({
          ...product,
          configSets: !!product.configSets
            ? sortConfigSets(product.configSets)
            : product.configSets,
        })),
        R.sortBy(JSON.stringify),
      );

    handleRkeeperProducts(crudSdk)(
      fixtures.rkeeperUnit?.externalId ?? 'Something is wrong',
      fixtures.rawData,
    )
      .pipe(
        delay(ES_DELAY),
        switchMap(() =>
          crudSdk.SearchGeneratedProducts({
            filter: { unitId: { eq: fixtures.rkeeperUnit.id } },
          }),
        ),
        filterNullishGraphqlListWithDefault<CrudApi.GeneratedProduct>([]),
        map(res =>
          processProducts<
            CrudApi.GeneratedProductConfigSet,
            CrudApi.GeneratedProduct
          >(res),
        ),
        tap(checkMatches('Generated products')),
        switchMap(() =>
          crudSdk.SearchUnitProducts({
            filter: { unitId: { eq: fixtures.rkeeperUnit.id } },
          }),
        ),
        filterNullishGraphqlListWithDefault<CrudApi.UnitProduct>([]),
        map(res =>
          processProducts<CrudApi.ProductConfigSet, CrudApi.UnitProduct>(res),
        ),
        tap(checkMatches('Unit products')),
        switchMap(() =>
          crudSdk.SearchGroupProducts({
            filter: { groupId: { eq: fixtures.rkeeperUnit.groupId } },
          }),
        ),
        filterNullishGraphqlListWithDefault<CrudApi.GroupProduct>([]),
        tap(checkMatches('Group products')),
        switchMap(() =>
          crudSdk.SearchChainProducts({
            filter: { chainId: { eq: fixtures.rkeeperUnit.chainId } },
          }),
        ),
        filterNullishGraphqlListWithDefault<CrudApi.ChainProduct>([]),
        tap(checkMatches('Chain products')),
        switchMap(() =>
          crudSdk.SearchProductComponents({
            filter: { chainId: { eq: fixtures.rkeeperUnit.chainId } },
          }),
        ),
        filterNullishGraphqlListWithDefault<CrudApi.ProductComponent>([]),
        tap(checkMatches('Product components')),
        switchMap(() =>
          crudSdk.SearchProductComponentSets({
            filter: { chainId: { eq: fixtures.rkeeperUnit.chainId } },
          }),
        ),
        filterNullishGraphqlListWithDefault<CrudApi.ProductComponentSet>([]),
        tap(checkMatches('Product component sets')),
      )
      .subscribe({
        next: () => done(),
      });
  }, 35000);

  // We skip this extremely long-running test by default
  test.skip('Test full rkeeper product handling - the use case with lots of records', done => {
    const rawData = JSON.parse(
      fs.readFileSync(__dirname + '/menu-data.json').toString(),
    );

    handleRkeeperProducts(crudSdk)(
      fixtures.realTestExternalId,
      rawData,
    ).subscribe({
      next: result => {
        expect(result).toMatchSnapshot();
        done();
      },
    });
  }, 720000);

  // We skip this extremely long-running test by default
<<<<<<< HEAD
  test.only('Test the product handling logic in fargate', done => {
||||||| 635c3166
  test.skip('Test the product handling logic in fargate', done => {
=======
  test('Test the product handling logic in fargate', done => {
>>>>>>> 7fd33dc485e1eab8a80512b80b7809f58290d782
    const deps = {
      ecs: new ECS({ apiVersion: '2014-11-13' }),
      RKeeperProcessProductSubnet:
        commonStackConfig['common-backend-anyupp'].AnyuppVpcSubnetOutput,
      RKeeperProcessProductSecurityGroup:
        commonStackConfig['common-backend-anyupp'].AnyuppVpcSecurityGroupOutput,
      taskDefinitionArn:
        stackConfig['anyupp-backend-rkeeper'].RKeeperTaskDefinitionArn,
    };

    handleProducts(deps)(fixtures.realTestExternalId, fixtures.rawData)
      .pipe(
        // Let the fargate provision its task
        delay(10000),
        switchMap(() =>
          crudSdk.SearchGeneratedProducts({
            filter: { unitId: { eq: fixtures.rkeeperUnit.id } },
          }),
        ),
        tap(result => expect(result?.items?.length).toMatchSnapshot()),
      )
      .subscribe(() => done());
  }, 20000);

  test('createDefaultProductCategory', done => {
    getBusinessEntityInfo(crudSdk)(
      fixtures.rkeeperUnit?.externalId ?? 'Something is wrong',
    )
      .pipe(
        switchMap(businessEntityInfo =>
          createDefaultProductCategory(crudSdk)(businessEntityInfo).pipe(
            tap(res => expect(res).toMatchSnapshot('product category created')),
            switchMap(() =>
              createDefaultProductCategory(crudSdk)(businessEntityInfo),
            ),
            tap(res =>
              expect(res).toMatchSnapshot('product category recreated'),
            ),
            switchMap(() =>
              crudSdk.GetProductCategory({
                id: defaultProductCategoryId(businessEntityInfo),
              }),
            ),
            tap(res =>
              expect(res).toMatchSnapshot(dateMatcher, 'product category data'),
            ),
          ),
        ),
      )
      .subscribe(() => done());
  }, 15000);
});
