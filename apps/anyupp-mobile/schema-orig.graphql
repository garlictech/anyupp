type Address {
  address: String
  city: String
  country: String
  title: String
  postalCode: String
  location: Location
}

type Location {
  lat: Float
  lng: Float
}

input AddressInput {
  address: String
  city: String
  country: String
  title: String
  postalCode: String
  location: LocationInput
}

input LocationInput {
  lat: Float
  lng: Float
}

type LocalizedItem {
  en: String
  de: String
  hu: String
}

input LocalizedItemInput {
  en: String
  de: String
  hu: String
}

# AdminUser

type AdminUser {
  id: ID!
  name: String
  profileImage: String
  roles: AdminUserRole!
  settings: AdminUserSettings
  address: Address
  email: String
  phone: String
}

type AdminUserRole {
  role: String!
  entities: [AdminRoleEntity]
}

type AdminRoleEntity {
  chainId: String
  groupId: String
  unitId: String
}

type AdminUserSettings {
  selectedChainId: String
  selectedGroupId: String
  selectedUnitId: String
  selectedProductCategoryId: String
  selectedLanguage: String
  selectedHistoryDate: Int
}

input CreateAdminUserInput {
  name: String!
  address: AddressInput
  email: String!
  phone: String
  profileImage: String
}

input UpdateAdminUserInput {
  id: ID!
  name: String
  address: AddressInput
  email: String
  phone: String
  profileImage: String
}

input AdminUserRoleInput {
  role: String!
  entities: [AdminRoleEntityInput]
}

input AdminRoleEntityInput {
  chainId: String
  groupId: String
  unitId: String
}

# Stripe

# STRIPE schema example https://github.com/jferrettiboke/stripe-graphql/blob/master/generated/schema.graphql

# https://stripe.com/docs/api/cards/object?lang=node
# Card brand
enum CardBrand {
  amex
  diners
  discover
  jcb
  mastercard
  unionpay
  visa
  unknown
}

# https://stripe.com/docs/api/cards/object?lang=node#card_object-funding
# Card funding type
enum CardFundingType {
  credit
  debit
  prepaid
  unknown
}

# enum StripePaymentMethodType {
#   alipay
#   au_becs_debit
#   bacs_debit
#   bancontact
#   card
#   eps
#   fpx
#   giropay
#   grabpay
#   ideal
#   oxxo
#   p24
#   sepa_debit
#   sofort
# }

type CardChecks {
  address_line1_check: String
  address_postal_code_check: String
  cvc_check: String
}

# https://stripe.com/docs/api/metadata?lang=node
# Updateable Stripe objects
type StripeMetadata {
  key: String!
  value: String!
}

type StripeCard {
  brand: CardBrand
  checks: CardChecks
  country: String
  last4: String
  exp_month: Int
  exp_year: Int
  fingerprint: String
  funding: CardFundingType
  three_d_secure: String
  # wallet: String # to do
  # IMPLEMENTED INTERFACES
  id: ID!
  object: String!
  metadata: [StripeMetadata!]!
}

# Chain

type Chain {
  id: ID!
  name: String
  description: LocalizedItem
  style: ChainStyle
  isActive: Boolean
}

type ChainStyle {
  colors: ChainStyleColors
  images: ChainStyleImages
}

type ChainStyleColors {
  backgroundLight: String
  backgroundDark: String
  borderLight: String
  borderDark: String
  disabled: String
  highlight: String
  indicator: String
  textLight: String
  textDark: String
}

type ChainStyleImages {
  header: String
  logo: String
}

input CreateChainInput {
  name: String
  description: LocalizedItemInput
  style: ChainStyleInput
  isActive: Boolean
}

input UpdateChainInput {
  id: ID!
  name: String
  description: LocalizedItemInput
  style: ChainStyleInput
  isActive: Boolean
}

input ChainStyleInput {
  colors: ChainStyleColorsInput
  images: ChainStyleImagesInput
}

input ChainStyleColorsInput {
  backgroundLight: String
  backgroundDark: String
  borderLight: String
  borderDark: String
  disabled: String
  highlight: String
  indicator: String
  textLight: String
  textDark: String
}

input ChainStyleImagesInput {
  header: String
  logo: String
}

# Group
type Group {
  id: ID!
  chainId: ID!
  name: String
  description: LocalizedItem
  currency: String
  address: Address
  email: String
  phone: String
}

input CreateGroupInput {
  chainId: ID!
  name: String
  description: LocalizedItemInput
  currency: String
  address: AddressInput
  email: String
  phone: String
}

input UpdateGroupInput {
  id: ID!
  chainId: ID!
  name: String
  description: LocalizedItemInput
  currency: String
  address: AddressInput
  email: String
  phone: String
}

# OrderItem
type StatusLog {
  userId: ID
  status: String
  ts: Int
}

type PriceShown {
  currency: String
  pricePerUnit: Float
  priceSum: Float
  tax: Int
  taxSum: Float
}

input PriceShownInput {
  currency: String
  pricePerUnit: Float
  priceSum: Float
  tax: Int
  taxSum: Float
}

type OrderItem {
  id: ID!
  created: Int
  productName: LocalizedItem
  priceShown: PriceShown
  productId: ID
  quantity: Int
  statusLog: [StatusLog]
  variantId: ID
  variantName: LocalizedItem
  laneId: ID
}

input CreateOrderItemInput {
  productName: LocalizedItemInput
  priceShown: PriceShownInput
  productId: ID
  quantity: Int
  variantId: ID
  variantName: LocalizedItemInput
  laneId: ID
}

input UpdateOrderItemInput {
  id: ID!
  productName: LocalizedItemInput
  priceShown: PriceShownInput
  productId: ID
  quantity: Int
  variantId: ID
  variantName: LocalizedItemInput
  laneId: ID
}

# Order
type Order {
  id: ID!
  created: Int
  items: [OrderItem]
  paymentMethod: String
  staffId: ID
  statusLog: [StatusLog]
  sumPriceShown: PriceShown
  takeAway: Boolean
  userId: ID
  place: Place
  paymentIntention: Int
}

type Place {
  seat: String
  table: String
}

input PlaceInput {
  seat: String
  table: String
}

input CreateOrderInput {
  orderItems: [ID]
  paymentMethod: String
  staffId: ID
  sumPriceShown: PriceShownInput
  takeAway: Boolean
  userId: ID
  place: PlaceInput
  paymentIntention: Int
}

input UpdateOrderInput {
  id: ID!
  orderItems: [ID]
  paymentMethod: String
  staffId: ID
  sumPriceShown: PriceShownInput
  takeAway: Boolean
  userId: ID
  place: PlaceInput
  paymentIntention: Int
}

# ProductCategory
type ProductCategory {
  id: ID!
  description: LocalizedItem
  image: String
  name: LocalizedItem
  position: String
}

input CreateProductCategoryInput {
  description: LocalizedItemInput
  image: String
  name: LocalizedItemInput
  position: String
}

input UpdateProductCategoryInput {
  id: ID!
  description: LocalizedItemInput
  image: String
  name: LocalizedItemInput
  position: String
}

# ChainProduct
type ChainProduct {
  id: ID!
  # contains
  description: LocalizedItem
  extending: String
  image: String
  # ingredients
  isVisible: Boolean
  tax: Int
  name: LocalizedItem
  position: String
  productCategoryId: ID
  laneId: ID
  productType: String
  variants: [ProductVariant]
}

input CreateChainProductInput {
  description: LocalizedItemInput
  extending: String
  image: String
  # ingredients
  isVisible: Boolean
  tax: Int
  name: LocalizedItemInput
  position: String
  productCategoryId: ID
  laneId: ID
  productType: String
  variants: [ProductVariantInput]
}

input UpdateChainProductInput {
  id: ID!
  description: LocalizedItemInput
  extending: String
  image: String
  # ingredients
  isVisible: Boolean
  tax: Int
  name: LocalizedItemInput
  position: String
  productCategoryId: ID
  laneId: ID
  productType: String
  variants: [ProductVariantInput]
}

type ProductVariant {
  variantName: LocalizedItem
  pack: ProductVariantPack
  refGroupPrice: Float
  isAvailable: Boolean
  price: Float
  availabilities: [Availability]
  availableFrom: String
  position: String
}

input ProductVariantInput {
  variantName: LocalizedItemInput
  pack: ProductVariantPackInput
  refGroupPrice: Float
  isAvailable: Boolean
  price: Float
  availabilities: [AvailabilityInput]
  availableFrom: String
  position: String
}

type ProductVariantPack {
  size: Float
  unit: String
}

input ProductVariantPackInput {
  size: Float
  unit: String
}

type Availability {
  type: String
  dayFrom: String
  dayTo: String
  timeFrom: String
  timeTo: String
  price: Float
}

input AvailabilityInput {
  type: String
  dayFrom: String
  dayTo: String
  timeFrom: String
  timeTo: String
  price: Float
}
# Unit
type Unit {
  id: ID!
  groupId: ID!
  isActive: Boolean
  isAcceptingOrders: Boolean
  name: String
  description: LocalizedItem
  paymentModes: [PaymentMode]
  floorMap: FloorMapData
  lanes: [Lane]
  open: DailySchedule
  openingHours: WeeklySchedule
}

input CreateUnitInput {
  groupId: ID!
  isActive: Boolean
  isAcceptingOrders: Boolean
  name: String
  description: LocalizedItemInput
  paymentModes: [PaymentModeInput]
  floorMap: FloorMapDataInput
  lanes: [LaneInput]
  open: DailyScheduleInput
  openingHours: WeeklyScheduleInput
}

input UpdateUnitInput {
  id: ID!
  groupId: ID!
  isActive: Boolean
  isAcceptingOrders: Boolean
  name: String
  description: LocalizedItemInput
  paymentModes: [PaymentModeInput]
  floorMap: FloorMapDataInput
  lanes: [LaneInput]
  open: DailyScheduleInput
  openingHours: WeeklyScheduleInput
}

type DailySchedule {
  from: String
  to: String
}

input DailyScheduleInput {
  from: String
  to: String
}

type CustomDailySchedule {
  date: String
  from: String
  to: String
}

input CustomDailyScheduleInput {
  date: String
  from: String
  to: String
}

type WeeklySchedule {
  mon: DailySchedule
  tue: DailySchedule
  wed: DailySchedule
  thu: DailySchedule
  fri: DailySchedule
  sat: DailySchedule
  sun: DailySchedule
  override: [CustomDailySchedule]
}

input WeeklyScheduleInput {
  mon: DailyScheduleInput
  tue: DailyScheduleInput
  wed: DailyScheduleInput
  thu: DailyScheduleInput
  fri: DailyScheduleInput
  sat: DailyScheduleInput
  sun: DailyScheduleInput
  override: [CustomDailyScheduleInput]
}

type PaymentMode {
  name: String!
  caption: String
  method: String!
}

input PaymentModeInput {
  name: String!
  caption: String
  method: String!
}

type FloorMapData {
  w: Int
  h: Int
  objects: [FloorMapDataObject]
}

input FloorMapDataInput {
  w: Int
  h: Int
  objects: [FloorMapDataObjectInput]
}

type FloorMapDataObject {
  id: ID!
  t: String!
  c: String
  w: Int
  h: Int
  r: Int
  a: Int
  x: Int!
  y: Int!
  tID: String # Table ID
  sID: String # Seat Id
}

input FloorMapDataObjectInput {
  id: ID!
  t: String!
  c: String
  w: Int
  h: Int
  r: Int
  a: Int
  x: Int!
  y: Int!
  tID: String # Table ID
  sID: String # Seat Id
}

type Lane {
  id: ID
  name: String
  color: String
}

input LaneInput {
  id: ID
  name: String
  color: String
}

# User
type User {
  id: ID!
  name: String
  address: Address
  email: String
  phone: String
  profileImage: String
  login: String
}

input CreateUserInput {
  name: String
  address: AddressInput
  email: String
  phone: String
  profileImage: String
  login: String
}

input UpdateUserInput {
  id: ID!
  name: String
  address: AddressInput
  email: String
  phone: String
  profileImage: String
  login: String
}

# Operations

type Query {
  # Admin
  getAdminUser(id: ID!): AdminUser
  getAdminUsers: [AdminUser]

  # Chain
  getChain(id: ID!): Chain

  # Group
  getGroup(id: ID!): Group

  # OrderItem
  getOrderItem(id: ID!): OrderItem

  # Order
  getOrder(id: ID!): Order

  # ProductCategory
  getProductCategory(id: ID!): ProductCategory

  # ChainProduct
  getChainProduct(id: ID!): ChainProduct

  # Unit
  getUnit(id: ID!): Unit

  # User
  getUser(id: ID!): User

  # Stripe
  getCustomerStripeCards(customerId: ID): [StripeCard]

  # Hellobello
  hellobello(name: String!): String
}

type Mutation {
  # AdminUser
  createAdminUser(input: CreateAdminUserInput!): AdminUser
  updateAdminUser(input: UpdateAdminUserInput!): AdminUser
  deleteAdminUser(id: ID!): Boolean!
  updateAdminUserRole(input: AdminUserRoleInput!): Boolean!

  # Chain
  createChain(input: CreateChainInput!): Chain
  updateChain(input: UpdateChainInput!): Chain
  deleteChain(id: ID!): Boolean!

  # Group
  createGroup(input: CreateGroupInput!): Group
  updateGroup(input: UpdateGroupInput!): Group
  deleteGroup(id: ID!): Boolean!

  # OrderItem
  createOrderItem(input: CreateOrderItemInput!): OrderItem
  updateOrderItem(input: UpdateOrderItemInput!): OrderItem
  deleteOrderItem(id: ID!): Boolean!

  # Order
  createOrder(input: CreateOrderInput!): Order
  updateOrder(input: UpdateOrderInput!): Order
  deleteOrder(id: ID!): Boolean!

  # ProductCategory
  createProductCategory(input: CreateProductCategoryInput!): ProductCategory
  updateProductCategory(input: UpdateProductCategoryInput!): ProductCategory
  deleteProductCategory(id: ID!): Boolean!

  # ChainProduct
  createChainProduct(input: CreateChainProductInput!): ChainProduct
  updateChainProduct(input: UpdateChainProductInput!): ChainProduct
  deleteChainProduct(id: ID!): Boolean!

  # Unit
  createUnit(input: CreateUnitInput!): Unit
  updateUnit(input: UpdateUnitInput!): Unit
  deleteUnit(id: ID!): Boolean!

  # User
  createUser(input: CreateUserInput!): User
  updateUser(input: UpdateUserInput!): User
  deleteUser(id: ID!): Boolean!

  # Stripe
  startStripePayment(chainId: ID!, unitId: ID!, userId: ID!): String!
}

type Subscription {
  updatedAdminUser(id: ID!): AdminUser
  createdAdminUser: AdminUser
}
