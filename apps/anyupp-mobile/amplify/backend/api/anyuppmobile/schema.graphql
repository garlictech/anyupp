type Address @model(queries: null, subscriptions: null){
  address: String
  city: String
  country: String
  title: String
  postalCode: String
  location: Location @connection
}

type Location @model(queries: null, subscriptions: null) {
  lat: Float
  lng: Float
}

type LocalizedItem @model(queries: null, subscriptions: null) {
  en: String
  de: String
  hu: String
}

# AdminUser

type AdminUser @model(queries: null, subscriptions: null){
  id: ID!
  name: String
  profileImage: String
  roles: AdminUserRole! @connection
  settings: AdminUserSettings @connection
  email: String
  phone: String
}

type AdminUserRole @model(queries: null, subscriptions: null) {
  role: String!
  entities: [AdminRoleEntity] @connection
}

type AdminRoleEntity @model(queries: null, subscriptions: null) {
  chainId: String
  groupId: String
  unitId: String
}

type AdminUserSettings @model(queries: null, subscriptions: null) {
  selectedChainId: String
  selectedGroupId: String
  selectedUnitId: String
  selectedProductCategoryId: String
  selectedLanguage: String
  selectedHistoryDate: Int
}

# Stripe

# STRIPE schema example https://github.com/jferrettiboke/stripe-graphql/blob/master/generated/schema.graphql

# https://stripe.com/docs/api/cards/object?lang=node
# Card brand
enum CardBrand {
  amex
  diners
  discover
  jcb
  mastercard
  unionpay
  visa
  unknown
}

# https://stripe.com/docs/api/cards/object?lang=node#card_object-funding
# Card funding type
enum CardFundingType {
  credit
  debit
  prepaid
  unknown
}

type CardChecks @model(queries: null, subscriptions: null) {
  address_line1_check: String
  address_postal_code_check: String
  cvc_check: String
}

# https://stripe.com/docs/api/metadata?lang=node
# Updateable Stripe objects
type StripeMetadata @model(queries: null, subscriptions: null) {
  key: String!
  value: String!
}

type StripeCard @model(subscriptions: null) {
  brand: CardBrand
  checks: CardChecks @connection
  country: String
  last4: String
  exp_month: Int
  exp_year: Int
  fingerprint: String
  funding: CardFundingType
  three_d_secure: String
  # wallet: String # to do
  # IMPLEMENTED INTERFACES
  id: ID!
  object: String!
  metadata: [StripeMetadata!]! @connection
}

# Chain

type Chain @model(subscriptions: null) {
  id: ID!
  name: String
  description: LocalizedItem @connection
  style: ChainStyle @connection
  isActive: Boolean
}

type ChainStyle @model(queries: null, subscriptions: null) {
  colors: ChainStyleColors @connection
  images: ChainStyleImages @connection
}

type ChainStyleColors @model(queries: null, subscriptions: null) {
  backgroundLight: String
  backgroundDark: String
  borderLight: String
  borderDark: String
  disabled: String
  highlight: String
  indicator: String
  textLight: String
  textDark: String
}

type ChainStyleImages @model(queries: null, subscriptions: null) {
  header: String
  logo: String
}

# Group
type Group @model(subscriptions: null) {
  id: ID!
  chainId: ID!
  name: String
  description: LocalizedItem @connection
  currency: String
  address: Address @connection
  email: String
  phone: String
}

# OrderItem
type StatusLog @model(queries: null, subscriptions: null) {
  userId: ID
  status: String
  ts: Int
}

type PriceShown @model(queries: null, subscriptions: null) {
  currency: String
  pricePerUnit: Float
  priceSum: Float
  tax: Int
  taxSum: Float
}

type OrderItem @model(queries: null, subscriptions: null) {
  id: ID!
  created: Int
  productName: LocalizedItem @connection
  priceShown: PriceShown @connection
  productId: ID
  quantity: Int
  statusLog: [StatusLog] @connection
  variantId: ID
  variantName: LocalizedItem @connection
  laneId: ID
}

# Order
type Order @model {
  id: ID!
  created: Int
  items: [OrderItem] @connection
  paymentMethod: String
  staffId: ID
  statusLog: [StatusLog] @connection
  sumPriceShown: PriceShown @connection
  takeAway: Boolean
  userId: ID
  place: Place @connection
  paymentIntention: Int
}

type Place @model(queries: null, subscriptions: null) {
  seat: String
  table: String
}

# ProductCategory
type ProductCategory @model {
  id: ID!
  description: LocalizedItem @connection
  image: String
  name: LocalizedItem @connection
  position: String
}

# ChainProduct
type ChainProduct @model {
  id: ID!
  # contains
  description: LocalizedItem @connection
  extending: String
  image: String
  # ingredients
  isVisible: Boolean
  tax: Int
  name: LocalizedItem @connection
  position: String
  productCategoryId: ID
  laneId: ID
  productType: String
  variants: [ProductVariant] @connection
}

type ProductVariant @model(queries: null, subscriptions: null) {
  variantName: LocalizedItem @connection
  pack: ProductVariantPack @connection
  refGroupPrice: Float
  isAvailable: Boolean
  price: Float
  availabilities: [Availability] @connection
  availableFrom: String
  position: String
}

type ProductVariantPack @model(queries: null, subscriptions: null){
  size: Float
  unit: String
}

type Availability @model(queries: null, subscriptions: null) {
  type: String
  dayFrom: String
  dayTo: String
  timeFrom: String
  timeTo: String
  price: Float
}

# Unit
type Unit @model {
  id: ID!
  groupId: ID!
  isActive: Boolean
  isAcceptingOrders: Boolean
  name: String
  description: LocalizedItem @connection
  paymentModes: [PaymentMode] @connection
  floorMap: FloorMapData @connection
  lanes: [Lane] @connection
  open: DailySchedule @connection
  openingHours: WeeklySchedule @connection
}

type DailySchedule @model(queries: null, subscriptions: null) {
  from: String
  to: String
}

type CustomDailySchedule @model(queries: null, subscriptions: null) {
  date: String
  from: String
  to: String
}

type WeeklySchedule @model(queries: null, subscriptions: null) {
  mon: DailySchedule @connection
  tue: DailySchedule @connection
  wed: DailySchedule @connection
  thu: DailySchedule @connection
  fri: DailySchedule @connection
  sat: DailySchedule @connection
  sun: DailySchedule @connection
  overrides: [CustomDailySchedule] @connection
}

type PaymentMode @model(queries: null, subscriptions: null) {
  name: String!
  caption: String
  method: String!
}

type FloorMapData @model(queries: null, subscriptions: null) {
  w: Int
  h: Int
  objects: [FloorMapDataObject] @connection
}

type FloorMapDataObject @model(queries: null, subscriptions: null) {
  id: ID!
  t: String!
  c: String
  w: Int
  h: Int
  r: Int
  a: Int
  x: Int!
  y: Int!
  tID: String # Table ID
  sID: String # Seat Id
}

type Lane @model(queries: null, subscriptions: null) {
  id: ID
  name: String
  color: String
}

# User
type User @model {
  id: ID!
  name: String
  email: String
  phone: String
  profileImage: String
  login: String
}

#Favorites
type FavoriteProduct @model(subscriptions: null)
@key(name: "byUserAndChain", fields: ["userID", "chainID"])
@key(name: "byUserAndUnit", fields: ["userID", "unitID"], queryField:"favoritesByUserAndUnit")
{
  id: ID!
  userID: ID!
  chainID: ID!
  unitID: ID!
  product: ChainProduct @connection
}

type Subscription {
  onAdminUserChange: AdminUser @aws_subscribe(mutations: ["createAdminUser", "updateAdminUser"])
}
